//CODIGO PARA ALMACENAR DATOS EN LA MICRO SD_ Lectura manual

#include <Wire.h>
#include "Adafruit_TCS34725.h"
#include <SPI.h>
#include <SD.h>

#define SD_CS 10
#define MUESTRAS 20  

Adafruit_TCS34725 tcs = Adafruit_TCS34725(
  TCS34725_INTEGRATIONTIME_50MS, TCS34725_GAIN_4X 
);//2.4 ms,24 ms, 50 ms,101 ms, 154 ms, 600 ms,, 1X, 4X, 16X, 60X
File dataFile;

bool datasetExiste = false; // bandera para saber si ya hay dataset

// === Funciones de limpieza ===
uint16_t getMedian(uint16_t *arr, uint8_t n) {
  for (uint8_t i = 0; i < n - 1; i++) {
    for (uint8_t j = i + 1; j < n; j++) {
      if (arr[j] < arr[i]) {
        uint16_t tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp;
      }
    }
  }
  return arr[n / 2];
}

float movingAverage(uint16_t *arr, uint8_t n) {
  long suma = 0;
  for (uint8_t i = 0; i < n; i++) suma += arr[i];
  return (float)suma / n;
}

float emaFilter(uint16_t *arr, uint8_t n, float alpha = 0.3) {
  float ema = arr[0];
  for (uint8_t i = 1; i < n; i++) {
    ema = alpha * arr[i] + (1 - alpha) * ema;
  }
  return ema;
}

float applyIQR(uint16_t *arr, uint8_t n) {
  getMedian(arr, n); 
  int q1 = arr[n / 4];
  int q3 = arr[(3 * n) / 4];
  int iqr = q3 - q1;
  int lower = q1 - 1.5 * iqr;
  int upper = q3 + 1.5 * iqr;

  long suma = 0;
  int count = 0;
  for (uint8_t i = 0; i < n; i++) {
    if (arr[i] >= lower && arr[i] <= upper) {
      suma += arr[i];
      count++;
    }
  }
  return (count > 0) ? (float)suma / count : arr[n / 2];
}

void readColorFiltered(float &r, float &g, float &b, uint8_t rep = 7) {
  uint16_t rr[rep], gg[rep], bb[rep], c;
  for (uint8_t i = 0; i < rep; i++) {
    tcs.getRawData(&rr[i], &gg[i], &bb[i], &c);
    delay(40);
  }
  r = applyIQR(rr, rep);
  g = movingAverage(gg, rep);
  b = emaFilter(bb, rep, 0.4);
}

// === Función para borrar SD manualmente ===
void borrarDatosSD() {
  if (SD.exists("colores.csv")) {
    SD.remove("colores.csv");
    Serial.println(F("Archivo borrado."));
  }
  dataFile = SD.open("colores.csv", FILE_WRITE);
  if (dataFile) {
    dataFile.println(F("Clase,Muestra,R,G,B,Estado"));
    dataFile.close();
    Serial.println(F("Archivo nuevo creado."));
  }
  datasetExiste = false; // al borrar ya no hay dataset
}

void setup() {
  Serial.begin(9600);
  if (!tcs.begin()) {
    Serial.println(F("No se encontró el TCS34725.")); while (1);
  }
  if (!SD.begin(SD_CS)) {
    Serial.println(F("No se pudo inicializar la SD.")); while (1);
  }

  // Verificar si ya existe dataset
  if (SD.exists("colores.csv")) {
    datasetExiste = true;
    Serial.println(F("=== Dataset detectado en la SD ==="));
    Serial.println(F("No es necesario registrar nuevas muestras."));
    Serial.println(F("Si desea reiniciar el dataset escriba 'borrar datos'."));
  } else {
    Serial.println(F("No existe dataset, puede iniciar registro de muestras."));
  }

  Serial.println(F("\n=== Sistema listo ==="));
  Serial.println(F("Comandos disponibles:"));
  Serial.println(F(" - 'borrar datos' -> reinicia el archivo en la SD"));
  Serial.println(F(" - 'ok' -> confirma guardar la muestra actual"));
  Serial.println(F(" - 'saltar' -> vuelve a pedir la misma muestra"));
}

void loop() {
  // Si ya existe dataset, no permitir registro automático
  if (datasetExiste) {
    // Solo escuchar comandos
    if (Serial.available()) {
      String cmd = Serial.readStringUntil('\n');
      cmd.trim();
      if (cmd.equalsIgnoreCase("borrar datos")) {
        borrarDatosSD();
        Serial.println(F("Archivo reiniciado, reinicie el Arduino para registrar nuevas muestras."));
      }
    }
    return; // salir del loop
  }

  // Registro de muestras
  for (uint8_t clase = 1; clase <= 3; clase++) {
    Serial.print(F("\n=== Clase ")); Serial.print(clase); Serial.println(F(" ==="));

    for (uint8_t i = 0; i < MUESTRAS; i++) {
      bool guardada = false;
      while (!guardada) {
        float r, g, b;
        readColorFiltered(r, g, b);

        // Mostrar muestra pendiente
        Serial.print(F("Muestra ")); Serial.print(i + 1);
        Serial.print(F(": R=")); Serial.print(r);
        Serial.print(F(" G=")); Serial.print(g);
        Serial.print(F(" B=")); Serial.println(b);
        Serial.println(F("Escriba 'ok' para guardar, 'saltar' para volver a tomarla o 'borrar datos'."));

        bool decision = false;
        while (!decision) {
          if (Serial.available()) {
            String cmd = Serial.readStringUntil('\n');
            cmd.trim();

            if (cmd.equalsIgnoreCase("ok")) {
              decision = true;
              guardada = true;
              dataFile = SD.open("colores.csv", FILE_WRITE);
              if (dataFile) {
                dataFile.print(clase); dataFile.print(",");
                dataFile.print(i + 1); dataFile.print(",");
                dataFile.print(r, 2); dataFile.print(",");
                dataFile.print(g, 2); dataFile.print(",");
                dataFile.print(b, 2); dataFile.print(",");
                dataFile.println("Limpia");
                dataFile.close();
              }
              Serial.println(F("✅ Muestra guardada en SD."));
            }
            else if (cmd.equalsIgnoreCase("saltar")) {
              decision = true;
              Serial.println(F("⏩ Muestra ignorada, se repetirá la misma."));
              // guardada se mantiene en false → se repite el while
            }
            else if (cmd.equalsIgnoreCase("borrar datos")) {
              borrarDatosSD();
              Serial.println(F("Archivo reiniciado, reinicie el Arduino para registrar nuevas muestras."));
              return;
            }
          }
        }
      }
    }
    Serial.println(F("Clase completada."));
  }

  Serial.println(F("=== Registro de dataset finalizado ==="));
  datasetExiste = true;
  while (1); // detener ejecución
}
